# Стиль именования коммитов \[RU]

дата:: 05.07.2023\
версия:: 0.4

---

### Оглавление

- [Описание](#Описание)
	- [Что такое «коммит»?](#what-is-commit)
	- [Почему сообщения коммитов важны?](#why-is-important)
	- [Best practice советы](#best-practice)
- [Формат сообщений коммитов](#Синтаксис)
	- [Типы коммитов](#types-commits)
	- [Объяснение типов](#types-explain)
	- [Допустимые сочетания типов](#permissible-combinations-types)
- [Примеры сообщений](#Примеры)
- [Источники](#Источники)

---

<h1 id="Описание">Описание</h1>

Этот файл, описывающий стиль написания ясных сообщений для т.н. «коммитов», содержит _best-practice_ советы и _методы_ по написанию сообщений для последних.

Также этот документ по большей части соглашение, т.к. в его росте (что **важно**, а не строительстве[^1]) участвует не один человек, а некое множество. В связи с этим, это соглашение подвержено частому изменению.

Как дополнение к выше сказанному, это соглашение может помочь прояснить, что из себя представляют объекты `git'a` - коммиты, узнать лучшие практики и советы по созданию и (пере)написанию истории коммитов, почему важно писать хорошие сообщения.

<h2 id="what-is-commit">Что такое «коммит»?</h2>

Простыми словами, коммит - это своего рода снимок состояния файлов, записанные за какой-то период времени в локальном репозитории.

«Состояние» файлов, можно интерпретировать по-разному. Существует заблуждение о том, что коммит хранит лишь _разницу_ между состояниями файлов, т.е. хранит _изменения_ (что верно, ведь VCS хранить т.н `diff` патчи для файлов, которые уходят в корни UNIX системы, но это не верно для `git`). Коммиты [хранят состояния обо всех файлов](https://git-scm.com/book/ru/v2/Git-%D0%B8%D0%B7%D0%BD%D1%83%D1%82%D1%80%D0%B8-%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-Git) в т.н. `blob` (**b**inary **ob**jects - _bob_ -> _blob_ "бактерия", "капля") файлах.

<h2 id="why-is-important">Почему сообщения коммитов важны?</h2>

- Как и в романе, серия коммитов имеет повествовательную структуру, которая контекстуализирует «сюжет» вашего изменения в коде, что помогает держать картину разработки в голове
- Автоматически создаваемые `CHANGELOG’и` (о них позже)
- Коммуникация о характере изменения между товарищами по команде, общественностью и другими заинтересованными сторонами
- Людям проще участвовать в проекте, потому что им доступна более структурированная история коммитов
- Ускоряют и упрощает проверку кода
- Помогают объяснить вопросы, которые не могут быть описаны только кодом
- Экономят время и нервы (головняка меньше), не больше и не меньше

<h2 id="best-practice">Best practice советы</h2>

**Данный под-топик описывает <u>общие</u> советы ведения истории коммитов, а не те, что указаны стандартом.**

### Маленький коммит? - отлично!

Хорошей практикой считается делать множество атомарных коммитов, т.е. маленьких, которые отвечают за одну конкретную вещь. Даже если вы изменили одну строку (не нужно возводить данное понятие в абсолют, если вы коммитите каждый изменённый символ - вы больной).

### Каждый коммит, должен рассказать почему он появился на свет

Каждое сообщения коммита желательно должно обоснованно описывать изменения, которые попали в этот коммит. Также коммит не должен оставлять после себя таких вопросов как: 

- *А зачем это было сделано?*
- *Почему это было необходимо?* (желательно)
- *Что было сделано в итоге?*

### Ограничение для сообщения коммита

[Рекомендуется](https://git-scm.com/book/ru/v2/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B9-Git-%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%B8%D0%B5-%D0%B2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B5) использовать не более 50 символов для заголовка, а также не более 72 символа для тела сообщения коммита. [Пример](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).

### Заголовок отдельно от тела сообщения

Как правило коммиты имеют заголовок и тело. Для правильного отображения сообщений коммитов сторонними инструментами строго рекомендуется делать отступ заголовка от тела сообщения коммита:

```
# ХОРОШО
<Заголовок коммита #9832729385>

<Тело коммита, которое описывает изменения>
```

```
# ПЛОХО
<Заголовок коммита #9832729385>
<Тело коммита, которое описывает изменения>
```

### Не ставьте точку в конце заголовка.

Так как заголовок должен описывать сами изменения, то важно, чтобы он был емким и коротким. В связи с этим такой символ как `.` (точка) не совсем уместен.

### Оговаривать проблему в коммите

Как правило коммиты несут в себе изменения кода, которые были сделаны для устранения ошибок и т.п. Но читающий историю коммитов не будет иметь представления о них, если конечно не указывать какую проблему решает данный коммит). Поэтому если изменения решают чрезвычайную багу, то это должно быть оговорено в сообщении коммита, т.е. должна быть расписана проблема, которая возникла до устранения этим\* коммитом.

### Избегать сообщений без какого-либо контекста

```
# ПЛОХО
* Fix this
|
* Fix stuff
|
* It should work now
|
* Change stuff
|\
| * Adjust css
|/
* Add main
```

### `git push --force` не надо

Если вы не знаете что делаете и к чему это приведёт, не используйте `git push --force`, так как, если кратко, то она перетирает удалённый репозиторий **вашим** локальным репозиторием: то, что было у вас - стало общее, а то, что было общее - затирается в пространстве и времени.

Так что запомните! Если вы будете придерживаться данного совета, то всё будет хорошо!

Если не будете, люди возненавидят вас, от вас отвернуться друзья, ваша семья станет вас презирать, у вас будет пониженная мотивация, деградация, смерть. И гарантирую, что я, тот, кто сейчас клацает это, сможет обеспечить вам последние точно. :3

---

<h1 id="Синтаксис">Синтаксис</h1>

<h2 id="types-commits">Типы коммитов</h2>

Обычно с практикой приходит понимание того, что некоторые коммиты можно агрегировать в некое множество, олицетворяющие какую-либо область изменения кода: какие-то изменения включат в себя правку документацию, какие-то сугубо исправление опечаток, а другие вообще завязаны на рефакторинге кода, которые можно также разделить на подмножества различных изменений. В общем идея такая - каждый коммит можно связать семантически с какой либо из категорий.

В связи с выше сказанным, предлагается использовать следующие «категории» коммитов:

* **chore**: обычная поддержка кода, рутина. \#TODO: пояснить, что есть «рутина» поддержки кода
* **refact/refct**: рефакторинг определенного участка кодовой базы. \#TODO: далее можно выделить подмножества
* **feat**: новая фича, добавляемая к приложению; добавление функционала в приложение.
* **meta**: всё, что связано о данных, которые рассказывают о других данных.[^2]
* **style**: обновления, имеющие отношение к стилизации, но, **<u>ВАЖНО</u>**, не меняющие работу (бизнес логику) приложения.
* **add/ad**: добавление новых элементов в проект таких как: файлы, директории и т.п.
* **rm**: удаление элементов проекта: файлы, директории и т.п.
* **project**: всё, что касается изменения конфигурационных и т.п. файлов. [^3]
* **typo**: изменения, касаемые исправления опечаток.
* **docs**: всё, что касается документации.
* **merge**: merge-коммиты.
* **rebase**: rebase-коммиты.
* **fix**: исправление баги.
* **test**: всё, что касается тестирования.

### Синтаксис шапки коммита

Первым делом коммит это заголовок. Именно заголовки читаются, как коммиты. Поэтому важно, что бы они были, как солдаты в строю, но за исключением того, что они должны связывать изменения, хранящиеся внутри, с категориям указанными выше. Посему предлагается следующий синтаксис т.н. «шапки» коммита:

```
[<type>#<local'>] <Заголовок>
```

Где \<type> собсна и связывает «контент» коммита c множеством категорий (об это ниже). Также прошу обратить внимание, что тип указывается в некой «корзинке», а именно в квадратных скобках - `[ ]`. В «корзине» также присутствует поле \<local>, которое является необязательным (на это указывает символ `'`); это поле предназначено для конкретизации места изменения кода: будто изменения были в директории, относящийся к тестированию, или в каком-то файле. Между «корзинкой» и заголовком пробел. И главное - заголовок. Заголовок у нас на районе принято писать с большой буквы, потому что потому[^4]. Далее рассматривается правила письма типа и заголовка коммита.

### Разновидности типов для коммитов

Часто бывает так, что изменения внесённые в файл можно сразу определить к нескольким категориям, *~~или же кому то было лень сделать коммит раньше)~~*. В любом случае имеются ситуации, когда изменения можно отнести к разным категориям (но важно к каким именно, об этом ниже).

\- *Какие это такие ситуации?*

Например, когда вы изменили опечатку в README.md файле (typo, meta) или же изменили структуру в файлах конфигурации проекта (style, project).

Для таких случаев у нас имеются т.н. «множества категорий» (МК далее), которые представляют из себя конкретизацию типов: если вы изменили документацию тестов, вы можете указать тип `style`, а можете конкретизировать область изменений, добавив тип `test`. Но тут есть некоторые оговорки того, как это написать.

Во-первых синтаксис использования МК таков:

```
[<type_0>:<type_1>]
```

Где \<type_0> есть более ***общая*** категория, а \<type_1> ***конкретная*** область изменений. То есть есть вы сделали исправление опечатки (typo), то именно `typo` должна занять место \<type_1>. А то в какой из «подкатегории» вы это сделали - указывается в \<type_0>. Для примера выше должен[^5] указывается тип `[test:typo]`. 

Во-вторых здесь **<u>важно не перепутать</u>**, потому что категории логически семантичны и мы не может указать тип, который бы говорил за себя, что он отвечает за «исправления документации в рефакторинге» -> `[docs:refact]`. Но при этом возможен случай, когда производиться «рефакторинг документации» -> `[refact:docs]`.

Также мы категорически предполагаем, что коммит не будет связан с более чем двумя категориями (*как это представить?*). Т.е. если указывается МК то это множество имеет кардинальное число 2: тип 0 и тип 1 - вот и всё!

<h2 id="types-explain">Объяснение типов</h2>

### \[chore]

### \[refact]

### \[feat]

### \[meta]

### \[style]

### \[add/ad]

### \[rm]

### \[project]

### \[typo]

### \[docs]

### \[merge]

### \[rebase]

### \[fix]

### \[test]

<h2 id="permissible-combinations-types">Допустимые сочетания типов</h2>

---

<h1 id="Примеры">Примеры</h1>

---

<h1 id="Источники">Источники</h1>

* Книга «Про Git» (ProGit): https://git-scm.com/book/ru/v2
* Пример хорошего сообщения к коммиту от Tim pope: https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html

[^1]: Под данным выражением следует понимать, что процесс написание этого стандарта - это не чётко выверенный план, а это, скорее всего, импровизационное выращивание стандарта на почве тех проблем, которые будут возникать в процессе написания коммитов. Подобно _программам_, это документ _выращивается, а не строиться_.
[^2]: Метаданные - это данные о данных. Т.е. в качестве «meta» файлов (которые и будут подвергаться изменению) могут выступать README, LICENSE и другие похожие файлы.
[^3]: К «конфигурационным» файлам можно отнести такие: project.toml, .gitignore, requirements.txt, Makefile, Dockerfile и так далее и тому подобное.
[^4]: С большой буквы заголовок смотрится полнее, тогда как с маленькой уместно использовать заголовки, включающее в себя не больше 3-4 слова.
[^5]: Под «должен» подразумевается - «опционально», но, конечно, если вы не собираетесь использовать МК.

